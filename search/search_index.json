{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DecisionTracker","text":"<p>DecisionTracker is a Python library for writing explainable, traceable, and auditable Python programs.</p> <p>Using monadic patterns, the library provides the [DecisionTracker syntax] for writing logic and math operations and control flow. Through this syntax, it allows one or more trees of expressions to be built up under the hood. A tree represents some code paths, math, and logic of the program. Each tree can be evaluated to a final value, equivalent to obtaining one of the outputs of the program if it had been written using vanilla Python syntax instead of DecisionTracker syntax.</p> <p>In addition, the tree can be simplified to represent only the logic and math of the code path taken to arrive at the tree\u2019s final value. This simplified tree can be flattened to a list of Evaluated Expressions, which can be stored in [dedicated database tables]. This allows program executions and outputs to be explained, traced, and audited at a level of thoroughness and ease which traditional logging cannot provide.</p> <p>Furthermore, the library is accompanied by the DecisionTracker Grafana panel, allowing the simplified tree to be reconstructed from the Evaluated Expressions stored in the database, and then viewed interactively.</p> <p>Note</p> <p>DecisionTracker does not need you to set up an additional database or service. It is intended for internal use by development and QA teams with existing tech stacks. DecisionTracker is intended to use your existing relational database and, optionally, your existing [Grafana] instance.</p> <p>The following diagram illustrates the end-to-end flow:</p> <p></p> <ol> <li> <p>The logic, math, and code paths of a Python program are written in DecisionTracker syntax. The output expression is actually a tree of expressions. The [<code>value</code>] property computes its final value. The [<code>to_db</code>] method converts the tree to a simplified tree of Evaluated Expressions and inserts them into your database along with some <code>metadata</code>.</p> </li> <li> <p>The Evaluated Expressions and their metadata are stored in <code>evaluated_expression</code>, <code>evaluated_expression_association</code>, and <code>evaluated_expression_metadata</code> tables in your relational database.</p> </li> <li> <p>Evaluated Expressions are queried from your database. The DecisionTracker Grafana panel reconstructs the simplified tree from the Evaluated Expressions and allows them to be viewed interactively.</p> </li> </ol>"},{"location":"#decisiontracker-syntax","title":"DecisionTracker syntax","text":"<p>DecisionTracker syntax is a re-implementation of a subset of Python syntax, in Python syntax, in order to support DecisionTracker\u2019s features. The subset of Python syntax that is supported represents the kind of code expressions that can be stored in a database and for which DecisionTracker offers explainability and traceability.</p>"},{"location":"#numeric-expressions","title":"Numeric expressions","text":"<p>In DecisionTracker syntax, numeric expressions are based on the <code>Numeric</code> class:</p> Regular Python syntax<pre><code>a, b, c, d, e = 0, 1, 2, 3, 4\n(a + b - c) * d / e\n</code></pre> DecisionTracker Python syntax<pre><code>Numeric(a=0).plus(b=1).minus(c=2).times(d=3).divided_by(e=4)\n</code></pre> <p>Note</p> <p>Just as in regular Python, use of <code>int</code>s and <code>float</code>s are interchangeable in the <code>Numeric</code> class. Performing a binary operation (e.g., addition) between two <code>int</code>s returns an <code>int</code>, performing a binary operation between two <code>float</code>s returns a <code>float</code>, and performing a binary operation between an <code>int</code> and a <code>float</code> returns a <code>float</code>. Division is the exception, which always returns a <code>float</code>.</p> <p>DecisionTracker syntax is evaluated from left to right. If we wanted to change the order of operations, we would instead write:</p> Regular Python syntax<pre><code>a, b, c, d, e = 0, 1, 2, 3, 4\na + b - c * d / e\n</code></pre> DecisionTracker Python syntax<pre><code>Int(Int(a=0).plus(b=1).minus(c=2)).times(d=3).divided_by(e=4)\n</code></pre> <p>A numeric expression can be converted to Evaluated Expressions, which can be seen in its string representation:</p> <pre><code>&gt;&gt;&gt; Int(Int(a=0).plus(b=1).minus(c=2)).times(d=3).divided_by(e=4)\n-0.75 because ((((a := 0) + (b := 1)) - (c := 2)) * (d := 3)) / (e := 4)\n</code></pre> <p>Note</p> <p>Nested addition operations, or nested multiplication operations, will be flattened, while maintaining the order of the operands and the final value.</p>"},{"location":"#comparisons","title":"Comparisons","text":"<p>Comparisons of numeric expressions can be written as follows. Comparisons return <code>Bool</code>s.</p> Regular Python syntax<pre><code>a == b\na != b\na &gt; b\na &gt;= b\na &lt; b\na &lt;= b\n</code></pre> DecisionTracker Python syntax<pre><code>Numeric(a).eq(b)\nNumeric(a).neq(b)\nNumeric(a).gt(b)\nNumeric(a).gte(b)\nNumeric(a).lt(b)\nNumeric(a).lte(b)\n</code></pre> <p>For example:</p> <pre><code>&gt;&gt;&gt; Numeric(a=4).gt(b=2)\nTrue because (a := 4) &gt; (b := 2)\n</code></pre> <p>However, when a comparison evaluates to <code>False</code>, the comparison gets flipped in its Evaluated Expression. For example:</p> <pre><code>&gt;&gt;&gt; Numeric(a=2).gt(b=4)\nFalse because (a := 2) &lt;= (b := 4)\n</code></pre>"},{"location":"#bool-expressions","title":"Bool expressions","text":"<p>In DecisionTracker syntax, bool expressions are based on the <code>Bool</code> class:</p> Regular Python syntax<pre><code>x, y, z = True, True, False\n(x or y) and not z\n</code></pre> DecisionTracker Python syntax<pre><code>Bool(x=True).or_(y=True).and_(Not(z=False))\n</code></pre> <p>Again, DecisionTracker syntax is evaluated from left to right. If we wanted to change the order of operations, we would instead write:</p> Regular Python syntax<pre><code>x, y, z = True, True, False\nx or y and not z\n</code></pre> DecisionTracker Python syntax<pre><code>Bool(x=True).or_(Bool(y=True).and(Not(z=False)))\n</code></pre> <p>Just like a numeric expression, a bool expression can be converted to Evaluated Expressions, which can be seen in its string representation:</p> <pre><code>&gt;&gt;&gt; Bool(x=True).or_(y=True).or_(z=True))\nTrue because (x := True) or (y := True) or (z := True)\n</code></pre> <pre><code>&gt;&gt;&gt; Bool(x=True).and_(y=True).and_(z=True)\nTrue because (x := True) and (y := True) and (z := True)\n</code></pre> <p>Note</p> <p>Nested \u201cor\u201d operations, or nested \u201cand\u201d operations, will be flattened, while maintaining the order of the operands and the final value.</p> <p>However, when the following get converted to Evaluated Expressions, things look a bit different. Click on the  icons to understand each case. These are examples of how Evaluated Expressions are not designed to represent the entire program, but to explain why it output certain values.</p> <ul> <li> <p> <pre><code>&gt;&gt;&gt; Bool(x=False).or_(y=True).or_(z=True)\nTrue because (y := True) or (z := True) # (1)!\n</code></pre></p> <ol> <li>Why does this Evaluated Expression omit <code>x</code>?  Because <code>x</code> did not contribute to the final value being <code>True</code>.</li> </ol> </li> <li> <p> <pre><code>&gt;&gt;&gt; Bool(x=False).or_(y=False).or_(z=False)\nFalse because (x := False) and (y := False) and (z := False) # (1)!\n</code></pre></p> <ol> <li>Why has \u201cor\u201d been replaced with \u201cand\u201d?  Because the final value could be <code>False</code> only if all the inputs were <code>False</code>.</li> </ol> </li> <li> <p> <pre><code>&gt;&gt;&gt; Bool(x=True).and_(y=False).and_(z=False)\nFalse because (y := False) or (z := False) # (1)!\n</code></pre></p> <ol> <li>Why does this Evaluated Expression omit <code>x</code>?  Because <code>x</code> did not contribute to the final value being <code>False</code>. <p> Why has \u201cand\u201d been replaced with \u201cor\u201d?  Because the final value could be <code>False</code> if any of the inputs were <code>False</code>. <li> <p> <pre><code>&gt;&gt;&gt; str(Not(x=True))\nFalse because (x := True) # (1)!\n&gt;&gt;&gt; str(Not(x=False))\nTrue because (x := False) # (2)!\n</code></pre></p> <ol> <li>Why do these Evaluated Expressions not include the \u201cnot\u201d operator?  Because, just like above, the operator is not considered to be causing the final value.</li> <li>Why do these Evaluated Expressions not include the \u201cnot\u201d operator?  Because, just like above, the operator is not considered to be causing the final value.</li> </ol> </li> <p>DecisionTracker supports alternate syntaxes for convenience or to suit user preferences:</p> <ul> <li><code>Bool(x).and_(y).and_(z))</code> can alternately be written as <code>Bool(x).and_(y, z)</code>.</li> <li><code>Bool(x).or_(Bool(y).and_(z))</code> can alternately be written as <code>Bool(x).or_(y, z)</code>.</li> </ul>"},{"location":"#if-elif-else-blocks","title":"If-elif-else blocks","text":"Regular Python syntax<pre><code>if a:\n    return a1\nelif b\n    return b1\nelse:\n    return c1\n</code></pre> DecisionTracker Python syntax<pre><code>return If(a).then(\n    a1\n).elif_(b).then(\n    b1\n).else_(\n    c1\n)\n</code></pre> <p>Obviously, you can have as many <code>.elif_(...).then(...)</code> cases as you wish (including none). However, unlike in regular Python syntax, a final <code>.else_(...)</code> is always required.</p>"},{"location":"#ternary-operators","title":"Ternary operators","text":"<p>Ternary operator expressions can be written as follows:</p> Regular Python syntax<pre><code>a, b, c = 1, True, 2\na if b else c\n</code></pre> DecisionTracker Python syntax<pre><code>Int(a=1).if_(b=True).else_(c=2)\n</code></pre> <p>Ternary operator expressions can be chained, but like this:</p> <pre><code>a if b else c if d else e\n</code></pre> <pre><code>Int(a).if_(b).else_(c.if_(d).else_(e))\n</code></pre> <p>Not like the following (which checks <code>d</code> before <code>b</code> and is likely not what is intended); simply keep in mind that DecisionTracker syntax is evaluated from left to right.</p> <pre><code>(a if b else c) if d else e\n</code></pre> <pre><code>Int(a).if_(b).else_(c).if_(d).else_(e)\n</code></pre>"},{"location":"#dict-lookups","title":"Dict lookups","text":"<p>Dictionary lookups can be written as follows:</p> Without a defaultWith a defaultWith a <code>None</code> default Regular Python syntax<pre><code>{\n    \"a\": a,\n    \"b\": b,\n}[x]\n</code></pre> DecisionTracker Python syntax<pre><code>Lookup(\n    {\n        \"a\": a,\n        \"b\": b,\n    },\n    x,\n)\n</code></pre> Regular Python syntax<pre><code>{\n    \"a\": a,\n    \"b\": b,\n}.get(x, c)\n</code></pre> DecisionTracker Python syntax<pre><code>UncertainLookup(\n    {\n        \"a\": a,\n        \"b\": b,\n    },\n    x,\n    c,\n)\n</code></pre> Regular Python syntax<pre><code>{\n    \"a\": a,\n    \"b\": b,\n}.get(x)\n</code></pre> DecisionTracker Python syntax<pre><code>val = UncertainLookup(\n    {\n        \"a\": a,\n        \"b\": b,\n    },\n    x,\n)\n</code></pre> <p>The return value of <code>.get(x)</code> should be checked to not be <code>None</code> before being used. Similarly, <code>IsNotNull(val)</code> should be checked before using <code>val</code> \u2014 that is, using <code>Numeric(val)</code> if its possible values are numeric, <code>Bool(val)</code> if boolean, and so on.</p>"},{"location":"#nullable-expressions","title":"Nullable expressions","text":"<p>In Python, <code>None</code> indicates the absence of a value. A variable of a certain type <code>T</code> becomes an optional variable when of type <code>Optional[T]</code> or, equivalently, of type <code>T | None</code>. The variable can only be treated as type <code>T</code> after checking that the variable <code>is not None</code>.</p> <p>In DecisionTracker syntax, the term nullable is used instead of optional. A DecisionTracker expression is nullable if its <code>.value</code> is of type <code>T | None</code> instead of just <code>T</code>. A nullable expression can be created from the <code>Nullable</code> class.</p> <p>For example, say your program has an input <code>x</code>, retrieved by function <code>get_x</code> with the following signature.</p> <pre><code>def get_x() -&gt; int | None: ...\n</code></pre> <p>In DecisionTracker syntax, this input must be wrapped with <code>Nullable</code>:</p> Regular Python syntax<pre><code>x = get_x() # (1)!\n</code></pre> <ol> <li><code>x</code> has type <code>int | None</code>.</li> </ol> DecisionTracker Python syntax<pre><code>x = Nullable(get_x()) # (1)!\n</code></pre> <ol> <li><code>x</code> has type <code>Nullable[int]</code>.</li> </ol> <p><code>Nullable</code> allows checking whether the nullable expression is null (by checking its properties <code>.is_null</code> or <code>.is_not_null</code>). This is useful, for example, to provide a fallback value:</p> Regular Python syntax<pre><code>y = x if x is not None else 0 # (1)!\n</code></pre> <ol> <li><code>y</code> has type <code>int</code>, not <code>int | None</code>, and Python\u2019s type checker knows this.</li> </ol> DecisionTracker Python syntax<pre><code>y = Numeric.from_(x).if_(x.is_not_null).else(0) # (1)!\n</code></pre> <ol> <li><code>y</code> has type <code>Numeric</code>, not <code>Nullable[int]</code>, and we had to explicitly establish that fact by starting our DecisionTracker expression with <code>Numeric</code>. <p> <code>Numeric.from_(x)</code> is analogous to <code>typing.cast(int, x)</code>. <p>Sometimes you want to use a variable (e.g., in a calculation) and, if it is null, \u2018persist\u2019 the null value:</p> <pre><code>y = x * 2 if x is not None else None # (1)!\n</code></pre> <ol> <li><code>y</code> has type <code>int | None</code>, just like <code>x</code>, and Python\u2019s type checker knows this.</li> </ol> <pre><code>y = Nullable(Numeric.from_(x).times(2)).if_(x.is_not_null).else_(None) # (1)!\n</code></pre> <ol> <li><code>y</code> has type <code>Nullable[int]</code>, just like <code>x</code>, and we had to explicitly establish that fact by starting our DecisionTracker expression with <code>Nullable</code>.</li> </ol>"},{"location":"#decisiontracker-expression","title":"DecisionTracker expression","text":""},{"location":"#property-value","title":"Property <code>value</code>","text":"<p>Compute and return the DecisionTracker expression\u2019s final value. The value of a <code>Bool</code> expression, for example, is a raw <code>bool</code>.</p>"},{"location":"#method-to_db","title":"Method <code>to_db</code>","text":"<p>Convert the DecisionTracker expression and its child expressions to a simplified tree of Evaluated Expressions, and then inserts them into [dedicated database tables].</p> <p>Arguments:</p> <ul> <li> <p><code>engine</code>: An SQLAlchemy <code>Engine</code> object with which to insert the Evaluated Expressions.</p> </li> <li> <p><code>metadata</code>: Key-value pairs of metadata for the DecisionTracker expression. Keys correspond to <code>evaluated_expression_metadata</code> table columns (e.g., <code>service_id</code>, <code>timestamp</code>).</p> </li> <li> <p><code>db_schema</code>: Name of the database schema containing the tables. Defaults to \u201cdecision_tracker\u201d.</p> </li> </ul>"},{"location":"#storage-of-evaluated-expressions-in-your-database","title":"Storage of Evaluated Expressions in your database","text":"<p>DecisionTracker requires dedicated tables in your relational database (e.g., Postgres), potentially in a dedicated schema.</p> <ul> <li> <p>The <code>evaluated_expression</code> table stores Evaluated Expressions (naturally).</p> </li> <li> <p>The <code>evaluated_expression_association</code> table stores the relationships between the Evaluated Expressions. Usually, this is a one-to-many (parent-children) relationship. However, because a child expression can be used and reused in more than one parent expression, this has been generalized to a many-to-many relationship which requires such an association table.</p> </li> <li> <p>The <code>evaluated_expression_metadata</code> table stores arbitrary, user-defined metadata for each root Evaluated Expression, specified when calling [<code>to_db</code>].</p> </li> </ul> <p>The following SQL script can be executed to create the tables. A single, dedicated schema called <code>\"decision_tracker\"</code> is recommended, especially if you plan on integrating multiple services with it. Adding <code>evaluated_expression_metadata</code> columns, such as a <code>service_id</code> and <code>timestamp</code>, is strongly recommended.</p> <pre><code>CREATE TABLE decision_tracker.evaluated_expression (\n    id UUID PRIMARY KEY,\n    name TEXT NULL,\n    value JSONB,\n    operator TEXT NOT NULL\n);\n\nCREATE TABLE decision_tracker.evaluated_expression_association (\n    child_id PRIMARY KEY UUID,\n    parent_id PRIMARY KEY UUID,\n\n    CONSTRAINT FOREIGN KEY child_id REFERENCES decision_tracker.evaluated_expression.id,\n    CONSTRAINT FOREIGN KEY parent_id REFERENCES decision_tracker.evaluated_expression.id\n);\n\nCREATE TABLE decision_tracker.evaluated_expression_metadata (\n    evaluated_expression_id PRIMARY KEY UUID,\n    &lt;your metadata columns here&gt;\n\n    CONSTRAINT FOREIGN KEY evaluated_expression_id REFERENCES decision_tracker.evaluated_expression.id,\n);\n</code></pre>"},{"location":"#interactive-viewing-using-the-grafana-panel","title":"Interactive viewing using the Grafana panel","text":"<p>Refer to the documentation of the DecisionTracker Grafana panel.</p> <p></p>"}]}