{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DecisionTracker","text":"<p>DecisionTracker is a Python library for writing explainable, traceable, and auditable Python programs.</p> <p>Using monadic patterns, the library provides a DecisionTracker syntax for writing logic and math operations and control flow. Through this syntax, it allows one or more trees of expressions to be built up under the hood. A tree represents some code paths, math, and logic of the program. Each tree can be evaluated to a final value, equivalent to obtaining one of the outputs of the program if it had been written using vanilla Python syntax instead of DecisionTracker syntax.</p> <p>In addition, the tree can be simplified to represent only the logic and math of the code path taken to arrive at the tree\u2019s final value. This simplified tree can be flattened to a list of Evaluated Expressions, which can be stored in a dedicated relational database table. This allows program executions and outputs to be explained, traced, and audited at a level of thoroughness and ease which traditional logging cannot provide.</p> <p>Furthermore, the library offers the DecisionTracker Grafana panel, allowing the simplified tree to be reconstructed from the Evaluated Expressions stored in the database, and then viewed interactively.</p> <p></p>"},{"location":"#decisiontracker-syntax","title":"DecisionTracker syntax","text":"<p>DecisionTracker syntax is a re-implementation of a subset of Python syntax, in Python syntax, in order to support DecisionTracker\u2019s features. The subset of Python syntax that is supported represents the kind of code expressions that can be stored in a database and for which DecisionTracker offers explainability and traceability.</p>"},{"location":"#numeric-expressions","title":"Numeric expressions","text":"<p>In DecisionTracker syntax, numeric expressions are based on the <code>Numeric</code> class:</p> Regular Python syntax<pre><code>a, b, c, d, e = 0, 1, 2, 3, 4\n(a + b - c) * d / e\n</code></pre> DecisionTracker Python syntax<pre><code>Numeric(a=0).plus(b=1).minus(c=2).times(d=3).divided_by(e=4)\n</code></pre> <p>Note</p> <p>Just as in regular Python, use of <code>int</code>s and <code>float</code>s are interchangeable in the <code>Numeric</code> class. Performing a binary operation (e.g., addition) between two <code>int</code>s returns an <code>int</code>, performing a binary operation between two <code>float</code>s returns a <code>float</code>, and performing a binary operation between an <code>int</code> and a <code>float</code> returns a <code>float</code>. Division is the exception, which always returns a <code>float</code>.</p> <p>DecisionTracker syntax is evaluated from left to right. If we wanted to change the order of operations, we would instead write:</p> Regular Python syntax<pre><code>a, b, c, d, e = 0, 1, 2, 3, 4\na + b - c * d / e\n</code></pre> DecisionTracker Python syntax<pre><code>Int(Int(a=0).plus(b=1).minus(c=2)).times(d=3).divided_by(e=4)\n</code></pre> <p>A numeric expression can be converted to Evaluated Expressions, which can be seen in its string representation:</p> <pre><code>&gt;&gt;&gt; Int(Int(a=0).plus(b=1).minus(c=2)).times(d=3).divided_by(e=4)\n-0.75 because ((((a := 0) + (b := 1)) - (c := 2)) * (d := 3)) / (e := 4)\n</code></pre> <p>Note</p> <p>Nested addition operations, or nested multiplication operations, will be flattened, while maintaining the order of the operands and the final value.</p>"},{"location":"#comparisons","title":"Comparisons","text":"<p>Comparisons of numeric expressions can be written as follows. Comparisons return <code>Bool</code>s.</p> Regular Python syntax<pre><code>a == b\na != b\na &gt; b\na &gt;= b\na &lt; b\na &lt;= b\n</code></pre> DecisionTracker Python syntax<pre><code>Numeric(a).eq(b)\nNumeric(a).neq(b)\nNumeric(a).gt(b)\nNumeric(a).gte(b)\nNumeric(a).lt(b)\nNumeric(a).lte(b)\n</code></pre> <p>For example:</p> <pre><code>&gt;&gt;&gt; Numeric(a=4).gt(b=2)\nTrue because (a := 4) &gt; (b := 2)\n</code></pre> <p>However, when a comparison evaluates to <code>False</code>, the comparison gets flipped. For example:</p> <pre><code>&gt;&gt;&gt; Numeric(a=2).gt(b=4)\nFalse because (a := 2) &lt;= (b := 4)\n</code></pre>"},{"location":"#bool-expressions","title":"Bool expressions","text":"<p>In DecisionTracker syntax, bool expressions are based on the <code>Bool</code> class:</p> Regular Python syntax<pre><code>x, y, z = True, True, False\n(x or y) and not z\n</code></pre> DecisionTracker Python syntax<pre><code>Bool(x=True).or_(y=True).and_(Not(z=False))\n</code></pre> <p>Again, DecisionTracker syntax is evaluated from left to right. If we wanted to change the order of operations, we would instead write:</p> Regular Python syntax<pre><code>x, y, z = True, True, False\nx or y and not z\n</code></pre> DecisionTracker Python syntax<pre><code>Bool(x=True).or_(Bool(y=True).and(Not(z=False)))\n</code></pre> <p>Just like a numeric expression, a bool expression can be converted to Evaluated Expressions, which can be seen in its string representation:</p> <pre><code>&gt;&gt;&gt; Bool(x=True).or_(y=True).or_(z=True))\nTrue because (x := True) or (y := True) or (z := True)\n</code></pre> <pre><code>&gt;&gt;&gt; Bool(x=True).and_(y=True).and_(z=True)\nTrue because (x := True) and (y := True) and (z := True)\n</code></pre> <p>Note</p> <p>Nested \u201cor\u201d operations, or nested \u201cand\u201d operations, will be flattened, while maintaining the order of the operands and the final value.</p> <p>However, when the following get converted to Evaluated Expressions, things look a bit different. Click on the  icons to understand each case. These are examples of how Evaluated Expressions are not designed to represent the entire program, but to explain why it output certain values.</p> <ul> <li> <p> <pre><code>&gt;&gt;&gt; Bool(x=False).or_(y=True).or_(z=True)\nTrue because (y := True) or (z := True) # (1)!\n</code></pre></p> <ol> <li>Why does this Evaluated Expression omit <code>x</code>?  Because <code>x</code> did not contribute to the final value being <code>True</code>.</li> </ol> </li> <li> <p> <pre><code>&gt;&gt;&gt; Bool(x=False).or_(y=False).or_(z=False)\nFalse because (x := False) and (y := False) and (z := False) # (1)!\n</code></pre></p> <ol> <li>Why has \u201cor\u201d been replaced with \u201cand\u201d?  Because the final value could be <code>False</code> only if all the inputs were <code>False</code>.</li> </ol> </li> <li> <p> <pre><code>&gt;&gt;&gt; Bool(x=True).and_(y=False).and_(z=False)\nFalse because (y := False) or (z := False) # (1)!\n</code></pre></p> <ol> <li>Why does this Evaluated Expression omit <code>x</code>?  Because <code>x</code> did not contribute to the final value being <code>False</code>. <p> Why has \u201cand\u201d been replaced with \u201cor\u201d?  Because the final value could be <code>False</code> if any of the inputs were <code>False</code>. <li> <p> <pre><code>&gt;&gt;&gt; str(Not(x=True))\nFalse because (x := True) # (1)!\n&gt;&gt;&gt; str(Not(x=False))\nTrue because (x := False) # (2)!\n</code></pre></p> <ol> <li>Why do these Evaluated Expressions not include the \u201cnot\u201d operator?  Because, just like above, the operator is not considered to be causing the final value.</li> <li>Why do these Evaluated Expressions not include the \u201cnot\u201d operator?  Because, just like above, the operator is not considered to be causing the final value.</li> </ol> </li> <p>DecisionTracker supports alternate syntaxes for convenience or to suit user preferences:</p> <ul> <li><code>Bool(x).and_(y).and_(z))</code> can alternately be written as <code>Bool(x).and_(y, z)</code>.</li> <li><code>Bool(x).or_(Bool(y).and_(z))</code> can alternately be written as <code>Bool(x).or_(y, z)</code>.</li> </ul>"},{"location":"#if-elif-else-blocks","title":"If-elif-else blocks","text":"Regular Python syntax<pre><code>if a:\n    return a1\nelif b\n    return b1\nelse:\n    return c1\n</code></pre> DecisionTracker Python syntax<pre><code>return If(a).then(\n    a1\n).elif_(b).then(\n    b1\n).else_(\n    c1\n)\n</code></pre> <p>Obviously, you can have as many <code>.elif_(...).then(...)</code> cases as you wish (including none). However, unlike in regular Python syntax, a final <code>.else_(...)</code> is always required.</p>"},{"location":"#ternary-operators","title":"Ternary operators","text":"<p>Ternary operator expressions can be written as follows:</p> Regular Python syntax<pre><code>a, b, c = 1, True, 2\na if b else c\n</code></pre> DecisionTracker Python syntax<pre><code>Int(a=1).if_(b=True).else_(c=2)\n</code></pre> <p>Ternary operator expressions can be chained, but like this:</p> <pre><code>a if b else c if d else e\n</code></pre> <pre><code>Int(a).if_(b).else_(c.if_(d).else_(e))\n</code></pre> <p>Not like the following (which checks <code>d</code> before <code>b</code> and is likely not what is intended); simply keep in mind that DecisionTracker syntax is evaluated from left to right.</p> <pre><code>(a if b else c) if d else e\n</code></pre> <pre><code>Int(a).if_(b).else_(c).if_(d).else_(e)\n</code></pre>"},{"location":"#dict-lookups","title":"Dict lookups","text":"<p>Dictionary lookups can be written as follows:</p> Without a defaultWith a defaultWith a <code>None</code> default Regular Python syntax<pre><code>{\n    \"a\": a,\n    \"b\": b,\n}[x]\n</code></pre> DecisionTracker Python syntax<pre><code>Lookup(\n    {\n        \"a\": a,\n        \"b\": b,\n    },\n    x,\n)\n</code></pre> Regular Python syntax<pre><code>{\n    \"a\": a,\n    \"b\": b,\n}.get(x, c)\n</code></pre> DecisionTracker Python syntax<pre><code>UncertainLookup(\n    {\n        \"a\": a,\n        \"b\": b,\n    },\n    x,\n    c,\n)\n</code></pre> Regular Python syntax<pre><code>{\n    \"a\": a,\n    \"b\": b,\n}.get(x)\n</code></pre> DecisionTracker Python syntax<pre><code>val = UncertainLookup(\n    {\n        \"a\": a,\n        \"b\": b,\n    },\n    x,\n)\n</code></pre> <p>The return value of <code>.get(x)</code> should be checked to not be <code>None</code> before being used. Similarly, <code>IsNotNull(val)</code> should be checked before using <code>val</code> \u2014 that is, using <code>Numeric(val)</code> if its possible values are numeric, <code>Bool(val)</code> if boolean, and so on.</p>"},{"location":"#nullable-expressions","title":"Nullable expressions","text":"<p>In Python, <code>None</code> indicates the absence of a value. A variable of a certain type <code>T</code> becomes an optional variable when of type <code>Optional[T]</code> or, equivalently, of type <code>T | None</code>. The variable can only be treated as type <code>T</code> after checking that the variable <code>is not None</code>.</p> <p>In DecisionTracker syntax, the term nullable is used instead of optional. A DecisionTracker expression is nullable if its <code>.value</code> is of type <code>T | None</code> instead of just <code>T</code>. A nullable expression can be created from the <code>Nullable</code> class.</p> <p>For example, say your program has an input <code>x</code>, retrieved by function <code>get_x</code> with the following signature.</p> <pre><code>def get_x() -&gt; int | None: ...\n</code></pre> <p>In DecisionTracker syntax, this input must be wrapped with <code>Nullable</code>:</p> Regular Python syntax<pre><code>x = get_x() # (1)!\n</code></pre> <ol> <li><code>x</code> has type <code>int | None</code>.</li> </ol> DecisionTracker Python syntax<pre><code>x = Nullable(get_x()) # (1)!\n</code></pre> <ol> <li><code>x</code> has type <code>Nullable[int]</code>.</li> </ol> <p><code>Nullable</code> allows checking whether the nullable expression is null (by checking its properties <code>.is_null</code> or <code>.is_not_null</code>). This is useful, for example, to provide a fallback value:</p> Regular Python syntax<pre><code>y = x if x is not None else 0 # (1)!\n</code></pre> <ol> <li><code>y</code> has type <code>int</code>, not <code>int | None</code>, and Python\u2019s type checker knows this.</li> </ol> DecisionTracker Python syntax<pre><code>y = Numeric.from_(x).if_(x.is_not_null).else(0) # (1)!\n</code></pre> <ol> <li><code>y</code> has type <code>Numeric</code>, not <code>Nullable[int]</code>, and we had to explicitly establish that fact by starting our DecisionTracker expression with <code>Numeric</code>. <p> <code>Numeric.from_(x)</code> is analogous to <code>typing.cast(int, x)</code>. <p>Sometimes you want to use a variable (e.g., in a calculation) and, if it is null, \u2018persist\u2019 the null value:</p> Regular Python syntax<pre><code>y = x * 2 if x is not None else None # (1)!\n</code></pre> <ol> <li><code>y</code> has type <code>int | None</code>, just like <code>x</code>, and Python\u2019s type checker knows this.</li> </ol> DecisionTracker Python syntax<pre><code>y = Nullable(Numeric.from_(x).times(2)).if_(x.is_not_null).else_(None) # (1)!\n</code></pre> <ol> <li><code>y</code> has type <code>Nullable[int]</code>, just like <code>x</code>, and we had to explicitly establish that fact by starting our DecisionTracker expression with <code>Nullable</code>.</li> </ol>"},{"location":"#migrating-existing-programs","title":"Migrating existing programs","text":"<p>TODO</p>"},{"location":"#storing-evaluated-expressions-in-a-database","title":"Storing Evaluated Expressions in a database","text":"<p>TODO</p>"},{"location":"#interactive-viewing-using-the-grafana-panel","title":"Interactive viewing using the Grafana panel","text":"<p>TODO</p>"}]}